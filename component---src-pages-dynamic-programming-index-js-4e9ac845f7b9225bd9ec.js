(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{rVkv:function(e,t,l){"use strict";l.r(t);var a=l("q1tI"),n=l.n(a),o=l("Bl7J"),r=l("Wbzz"),s=l("vrFN"),i=l("oSmq"),c=l("AzMy"),m=l("37PQ"),u=l("V4ez"),h=l("kfFl"),p=l("EQI2"),w=l("yv+Y"),E=l("tbs6"),d=l.n(E),g=l("TWRG"),b=l.n(g),f=l("l6lw"),y=l.n(f),A=l("dtER"),v=l.n(A),T=l("JqIj"),I=l.n(T),G=l("ZI/e"),C=l.n(G),N=l("c+0k"),D=l.n(N),k=l("i0hK"),x=l.n(k),W=l("Z/oY"),S=l.n(W),F=l("heHZ"),B=l.n(F),L=l("1ZW2"),q=l.n(L),z=l("eULd"),j=l.n(z),J=l("Idm2"),Y=l.n(J);t.default=function(){var e=Object(a.useState)(!1),t=e[0],l=e[1];return n.a.createElement(o.a,{location:"/dynamic-programming",currentLanguage:"Français"},n.a.createElement(s.a,{title:"Morpion"}),n.a.createElement("p",null,"In ",n.a.createElement(r.Link,{to:"/tic-tac-toe/fr"},"the article on tic-tac-toe"),", we solved the problem with a recurrence relation. But this solution is slow and so limited to small problems. Hopefully, it is possible to increase speed with"," ",n.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Dynamic_programming"},"dynamic programming"),". We leave useless games like tic-tac-toe to look at bioinformatics and DNA alignement with"," ",n.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm"},"Needleman-Wunsch algorithm"),"."),n.a.createElement("p",null,"Like in ",n.a.createElement(r.Link,{to:"/tic-tac-toe/fr"},"tic-tac-toe problem"),", DNA alignment can be resumed as a recurrence relation. If you use naïve computation, you will repeat many time similar problems. So here we will propose to save intermediate results in order to avoid to repeat computation."),n.a.createElement("h2",null,"Reminder in DNA"),n.a.createElement("p",null,"To be brief, all you gens are written on molecules named"," ",n.a.createElement("a",{href:"https://en.wikipedia.org/wiki/DNA"},"Deoxyribonucleic Acid (DNA)"),". But it's not written in English or in French. This molecule is only composed of 4 basic patterns. We will use 4 letters to represent them. So for us a DNA is a word made with only ",n.a.createElement("strong",null,"4 letters")," ","which are ",n.a.createElement("strong",null,"A"),", ",n.a.createElement("strong",null,"C"),", ",n.a.createElement("strong",null,"G"),","," ",n.a.createElement("strong",null,"T"),"."),n.a.createElement("p",null,"Just a little picture to represent how we simplified DNA. From molecular representation, to pattern representation and then words. lettres pour simplifier."),n.a.createElement("img",{src:d.a}),n.a.createElement("p",null,'If you wonder why we keep only one helix on the two, it\'s because they carry the same information. Look at the "T" on the opposite helix you will always find a "A". In the "C" is always with a "G". So if the first helix is "ACAGT", you know that the second will be "TGTCA". Knowing one of the two is enough.'),n.a.createElement("p",null,"Now we want to be able to compare two DNAs. For that we will try to match ass many letter as possible between the two words. In the exemple bellow, adding a space help us to align all the other letters."),n.a.createElement("img",{src:b.a}),n.a.createElement("h2",null,"Formalizing"),n.a.createElement("p",null,'We need to define what is a "good way" to align two DNAs. For that we will define a',n.a.createElement("strong",null,"score")," such that a ",n.a.createElement("strong",null,"good")," ","alignment has a ",n.a.createElement("strong",null,"high")," score. Of course, a"," ",n.a.createElement("strong",null,"bad")," alignment will have a ",n.a.createElement("strong",null,"low")," score."),n.a.createElement("p",null,"In an alignment we have 3 possibilities :"),n.a.createElement("ul",null,n.a.createElement("li",null,"Letters ",n.a.createElement(u.b,null,"match")," : That is what we want. So for each"," ",n.a.createElement(u.b,null,"match")," we give ",n.a.createElement(u.b,null,"+1"),"."," "),n.a.createElement("li",null,"Letters ",n.a.createElement(u.c,null,"miss-match")," : for exemple the A is replaced by T in the other DNA. It's a"," ",n.a.createElement(u.c,null,"substitution"),", we want to avoid that so we will give ",n.a.createElement(u.c,null,"-1")," each time it appends."),n.a.createElement("li",null,"Some time we prefer to use a ",n.a.createElement(u.a,null,"space"),". In order to improve alignement latter in the word we can prefer to use some spaces. Those ",n.a.createElement(u.a,null,"deletions"),", can append in DNAs but they are more rare than ",n.a.createElement(u.c,null,"substitution"),". So we will give ",n.a.createElement(u.a,null,"-2")," in order to say that we prefer"," ",n.a.createElement(u.c,null,"substitution")," to ",n.a.createElement(u.a,null,"space"),".")),n.a.createElement("p",null),n.a.createElement("p",null,"The score is just the sum of those values. Let see an exemple. If you count the number of ",n.a.createElement(u.b,null,"matches"),", of"," ",n.a.createElement(u.a,null,"deletions")," and ",n.a.createElement(u.c,null,"substitutions")," ","and you apply their respective ",n.a.createElement("strong",null,"score")," you get the following result.",n.a.createElement("br",null)," Score is : ",n.a.createElement(u.b,null,"1")," + ",n.a.createElement(u.c,null,"(-1)")," +"," ",n.a.createElement(u.b,null,"1")," + ",n.a.createElement(u.a,null,"(-2)")," + ",n.a.createElement(u.b,null,"1")," +"," ",n.a.createElement(u.c,null,"(-1)")," + ",n.a.createElement(u.c,null,"(-1)")," +"," ",n.a.createElement(u.b,null,"1")," = -1"),n.a.createElement("img",{src:y.a}),n.a.createElement("p",null,"Of course you can choose other values. In biology there is some tables in which they give the probabilities for a A to be replaced by a C, or by a T or just to be deleted. The score will be more relevant with those informations. But we don't care here."),n.a.createElement("h2",null,"Impossible to use naïve solution"),n.a.createElement("p",null,"Trying all the possibilities is just impossible. Let try to align 10 letters with 10 other ones. You can not modify letters order. All you can do is add some spaces. But you have 20 possibilities to put one space. If you want to consider solutions with 2 spaces you have 180 possibilities. For 3 spaces ? it's 1.140 possibilities It goes high fast. Too fast to be tractable with real DNAs which are made of hundreds and thousands of letters."),n.a.createElement("p",null,"So we can not try all the alignments and look at the one with the lowest score."),n.a.createElement("h2",null,"Recurrence relation are not enough"),n.a.createElement("p",null,"Trying every solution is not smart enough. So let's try"," ",n.a.createElement("strong",null,"recurrence"),". We are trying to get the best alignment of two DNAs. This alignment can finish with only 3 possibilities:"),n.a.createElement("ul",null,n.a.createElement("li",null,"We use the last letters of each DNA and they ",n.a.createElement(u.b,null,"match")," or they ",n.a.createElement(u.c,null,"substitution")),n.a.createElement("li",null,"We choose to use a ",n.a.createElement(u.a,null,"deletion")," for the first DNA"),n.a.createElement("li",null,"We choose to use a ",n.a.createElement(u.a,null,"deletion")," for the second DNA")),n.a.createElement("p",null),n.a.createElement("p",null,"For those who prefer a scheme, There are the 3 solutions."),n.a.createElement("img",{src:v.a}),n.a.createElement("p",null,"For each of those possibilities, we have two smaller DNAs to align. So we reuse the function on the remaining DNAs the compute there"," ",n.a.createElement("strong",null,"best score"),". Like for tic-tac-toe, we"," ",n.a.createElement("strong",null,"reduce the size of the problem")," at each time. So after some time we will reach size 0 and get the solution."),n.a.createElement("p",null,"Mathematically, the formula is the following one :"),n.a.createElement("img",{src:I.a}),n.a.createElement("p",null,"Do not panic if you don't understand it. Just read it slowly, it is the translation of what we said before. If you want I plot its results later in the article."),n.a.createElement("p",null,n.a.createElement("strong",null,"Problem")," : each time we use this equation, we get 3 smaller problems to solve. The we can say that we have an"," ",n.a.createElement("strong",null,"exponential complexity"),". In fact this algorithm do what we wanted to avoid. It try all the possibilities. But let se an exemple."),n.a.createElement("h2",null,'A feeling of "déjà vue"'),n.a.createElement("p",null,"Here is the ",n.a.createElement("strong",null,"tree of recurrence"),' for a really simple case, but an interesting one. We just want to aligne "ACGT" and "AGT". but out tree has already 130 leafs. You don\'t need to read it completely (you can click on it to get a full version) . You just need to notice that each problem leads to 3 othe ones which are a bit smaller. Untill we get a problem in which one of the DNA is empty so we can directly comput its score.'),n.a.createElement("img",{src:C.a,onClick:function(){l(!0)}}),n.a.createElement(h.a,{onClose:function(){l(!1)},open:t},n.a.createElement(w.a,null,"Tree of possible alignments"),n.a.createElement(p.a,null,n.a.createElement("img",{src:"",alt:""}))),n.a.createElement("p",null,"You noticed a pattern? No? Of course, there are too many details. So I cut i in three parts and use colors to represent problems. Each"," ",n.a.createElement("strong",null,"problem")," is associated to a unique"," ",n.a.createElement("strong",null,"color"),". So each time you see a box with the same color, it means that they compute the same thing. Computing the same thing? That's a bit stupid no?"),n.a.createElement("div",{className:Y.a.row},n.a.createElement("div",null,n.a.createElement("img",{src:D.a})),n.a.createElement("div",null,n.a.createElement("img",{src:x.a})),n.a.createElement("div",null,n.a.createElement("img",{src:S.a}))),n.a.createElement("p",null,"Here some exemples. Each time you see a ",n.a.createElement("strong",null,"light green")," ","box, it correspond to the alignment of ",n.a.createElement("strong",null,"A and A"),". The"," ",n.a.createElement("strong",null,"light blue")," correspond to ",n.a.createElement("strong",null,"ACG and A"),". The ",n.a.createElement("strong",null,"yellow")," are for ",n.a.createElement("strong",null,"ACG and AG"),", etc.",n.a.createElement("br",null)," So on this tree we compute :"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"25 times")," alignement between ",n.a.createElement("strong",null,"A")," and"," ",n.a.createElement("strong",null,"A")),n.a.createElement("li",null,n.a.createElement("strong",null,"5 times")," alignement between ",n.a.createElement("strong",null,"ACG")," and"," ",n.a.createElement("strong",null,"A")),n.a.createElement("li",null,n.a.createElement("strong",null,"3 times")," alignement between ",n.a.createElement("strong",null,"ACG")," and"," ",n.a.createElement("strong",null,"AG"))),n.a.createElement("p",null,"It's clearly a waste of ",n.a.createElement("strong",null,"computing power"),". To avoid this waste, we will need to store those results somewhere. Thanks to this storage, we will reduce"," ",n.a.createElement("strong",null,"time complexity"),", but it's not free since we neet to increase",n.a.createElement("strong",null,"memory complexity"),". It seems obscure for you ? Don't care, it will be okay after the next part."),n.a.createElement("h2",null,"The help of memoization"),n.a.createElement("p",null,"If you save in ",n.a.createElement("strong",null,"memory results of sub-problems"),', you will not have to redo the computation. So the first time you see the problem of aligning "ACG" with "A", you comput it and save the results. Each time you will see it in the futur you can get directly the result from memory. So in our tree each color box will appear only once.',n.a.createElement("br",null),"You can see the result of this technic in the tree bellow. It's the same except that I removed all the duplicated boxes. It's more efficient don't you think?"),n.a.createElement("img",{src:B.a}),n.a.createElement("p",null,"But how can we save all those results? We need something easy and fast to save score of all our ",n.a.createElement("strong",null,"sub-problems"),". For that let's start by counting how much sub-problem do we have."),n.a.createElement("p",null,"A sub-problem is aligning two subsequence of our DNAs. For exemple",n.a.createElement("strong",null,"subsequences"),' of "ACGTCG" are: "ACGTCG", "ACGTC", "ACGT", "ACG", "AC", "A" and "".'),n.a.createElement("p",null,"So if our DNAs are made with n and m letters, there is (n+1)"," ",n.a.createElement("strong",null,"subsequences")," for the first DNA and (m+1)"," ",n.a.createElement("strong",null,"subsequences")," for the second DNA. By combining them we get a total number of (n+1)(m+1) ",n.a.createElement("strong",null,"sub-problems"),". It will be easy to store the in a table with (n+1) rows and (m+1) columns."),n.a.createElement("p",null,"It's crazy ! We started form a ",n.a.createElement("strong",null,"recurrence relation")," ","which was time consuming, and we realize that it correspond to feeding a table."),n.a.createElement("p",null,"Here is an example of how this table work. It's easier to understand by playing with it. Just move your mouse on boxes to know the corresponding",n.a.createElement("strong",null,"sub-problem"),"."),n.a.createElement(i.a,{startWord1:"ABCDEFGHIJ",startWord2:"DEFGH",lang:"en"}),n.a.createElement("h2",null,"New version of the recurrence relation"),n.a.createElement("p",null,'We now have a table to feed. Now we will adapt the recurrence relation to this table. For that we will just use an exemple. If I want to aligne "ACGTC" and "AGGA" I still have tree possibilities for the end. Each of those possibilities are represented by a colour.'),n.a.createElement("img",{src:q.a}),n.a.createElement("p",null,"The two ",n.a.createElement(u.a,null,"deletions")," will always be"," ",n.a.createElement(u.a,null,"deletions"),". But the third can be a"," ",n.a.createElement(u.b,null,"match")," or a ",n.a.createElement(u.c,null,"substitution"),". We will have a ",n.a.createElement(u.b,null,"match")," if letters in the row and the column are the same and a ",n.a.createElement(u.c,null,"substitution"),"otherwise."),n.a.createElement("p",null,"Move your mouse bellow to complet the table with our new recurrence relation. If we have all the informations needed to fill the boxe the relation will be applied. otherwise one of the missing sub problem will be indicated."),n.a.createElement(c.a,{startWord1:"ATCGTCGA",startWord2:"AGGTGCGTA",lang:"en"}),n.a.createElement("p",null,"You probably notices tat to fill a box you need three other ones . The"," ",n.a.createElement("strong",null,"top"),", ",n.a.createElement("strong",null,"left")," and"," ",n.a.createElement("strong",null,"top left")," boxes. So after filling the first line nd first column, we can fill the table line by line, column by column or with more creative paths."),n.a.createElement("img",{src:j.a}),n.a.createElement("p",null,"To conclude, we now have the best score of all the",n.a.createElement("strong",null,"sub-problems"),". Noticed that we inversed the order of computation. Instead of starting by our problem and simplify it step by step, we start by easies sub problems and add elements until we reach our origina problem."),n.a.createElement("p",null,"So the best score of our problem is the one in the box at the last column and last line. The last box to be fill. We have the score but not the alignment to get it. But we can get it easily for the table."),n.a.createElement("p",null,"To get this ",n.a.createElement("strong",null,"best score"),"we can come from to 3 sub problems. Those in cases ",n.a.createElement("strong",null,"top"),", ",n.a.createElement("strong",null,"left")," and"," ",n.a.createElement("strong",null,"top left"),". So let compute which of those sub-problems allow to reach the best score. And we can repeat the operation until we get arrive in the first line or the first column. Notice that this path is not necessarily unique since there is not necessarily one optimal alignement. This algorithm allow us to recover all of them."),n.a.createElement(m.a,{startWord1:"ACGTCATC",startWord2:"ATGCGGC",lang:"en"}))}}}]);
//# sourceMappingURL=component---src-pages-dynamic-programming-index-js-4e9ac845f7b9225bd9ec.js.map