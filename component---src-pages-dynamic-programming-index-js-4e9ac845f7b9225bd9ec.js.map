{"version":3,"sources":["webpack:///./src/pages/dynamic-programming/index.js"],"names":["Page","useState","openFullTree","setOpenFullTree","location","currentLanguage","title","to","href","src","simplification_ADN","alignement","calcul_score","trois_possibilites","formule_rec_ADN","arbre_min","onClick","onClose","open","alt","className","classes","row","arbre_coupe1","arbre_coupe2","arbre_coupe3","arbre_elague","startWord1","startWord2","lang","recurrence_tableau","parcourt_tableau"],"mappings":"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","file":"component---src-pages-dynamic-programming-index-js-4e9ac845f7b9225bd9ec.js","sourcesContent":["import React, { useState } from \"react\"\n\nimport Layout from \"src/components/layout\"\nimport { Link } from \"gatsby\"\nimport SEO from \"src/components/seo\"\n\nimport InteractiveGrid from \"src/components/DynamicProgram/explanations/InteractiveGrid\"\nimport InteractiveRecurrence from \"src/components/DynamicProgram/explanations/InteractiveRecurrence\"\nimport FullAlgo from \"src/components/DynamicProgram/explanations/FullAlgo\"\n\nimport { Match, MissMatch, Deletion } from \"src/components/DynamicProgram/utils\"\n\nimport Dialog from \"@material-ui/core/Dialog\"\nimport DialogContent from \"@material-ui/core/DialogContent\"\nimport DialogTitle from \"@material-ui/core/DialogTitle\"\n\n//import images\nimport simplification_ADN from \"./images/simplification_ADN.png\"\nimport alignement from \"./images/alignement.png\"\nimport calcul_score from \"./images/calcul_score.png\"\nimport trois_possibilites from \"./images/trois_possibilites.png\"\nimport formule_rec_ADN from \"./images/formule_rec_ADN.png\"\nimport arbre_min from \"./images/arbre_min.svg\"\nimport arbre_coupe1 from \"./images/arbre_coupe1.svg\"\nimport arbre_coupe2 from \"./images/arbre_coupe2.svg\"\nimport arbre_coupe3 from \"./images/arbre_coupe3.svg\"\nimport arbre_elague from \"./images/arbre_elague.png\"\nimport recurrence_tableau from \"./images/recurrence_tableau.png\"\nimport parcourt_tableau from \"./images/parcourt_tableau.png\"\n\nimport classes from \"./style.module.scss\"\n\nconst Page = () => {\n  const [openFullTree, setOpenFullTree] = useState(false)\n\n  const handleClickOpen = () => {\n    setOpenFullTree(true)\n  }\n\n  const handleClose = () => {\n    setOpenFullTree(false)\n  }\n\n  return (\n    <Layout location=\"/dynamic-programming\" currentLanguage=\"Français\">\n      <SEO title=\"Morpion\" />\n\n      <p>\n        In <Link to=\"/tic-tac-toe/fr\">the article on tic-tac-toe</Link>, we\n        solved the problem with a recurrence relation. But this solution is slow\n        and so limited to small problems. Hopefully, it is possible to increase\n        speed with{\" \"}\n        <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">\n          dynamic programming\n        </a>\n        . We leave useless games like tic-tac-toe to look at bioinformatics and\n        DNA alignement with{\" \"}\n        <a href=\"https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm\">\n          Needleman-Wunsch algorithm\n        </a>\n        .\n      </p>\n      <p>\n        Like in <Link to=\"/tic-tac-toe/fr\">tic-tac-toe problem</Link>, DNA\n        alignment can be resumed as a recurrence relation. If you use naïve\n        computation, you will repeat many time similar problems. So here we will\n        propose to save intermediate results in order to avoid to repeat\n        computation.\n      </p>\n      <h2>Reminder in DNA</h2>\n      <p>\n        To be brief, all you gens are written on molecules named{\" \"}\n        <a href=\"https://en.wikipedia.org/wiki/DNA\">\n          Deoxyribonucleic Acid (DNA)\n        </a>\n        . But it's not written in English or in French. This molecule is only\n        composed of 4 basic patterns. We will use 4 letters to represent them.\n        So for us a DNA is a word made with only <strong>4 letters</strong>{\" \"}\n        which are <strong>A</strong>, <strong>C</strong>, <strong>G</strong>,{\" \"}\n        <strong>T</strong>.\n      </p>\n      <p>\n        Just a little picture to represent how we simplified DNA. From molecular\n        representation, to pattern representation and then words. lettres pour\n        simplifier.\n      </p>\n      <img src={simplification_ADN} />\n      <p>\n        If you wonder why we keep only one helix on the two, it's because they\n        carry the same information. Look at the \"T\" on the opposite helix you\n        will always find a \"A\". In the \"C\" is always with a \"G\". So if the first\n        helix is \"ACAGT\", you know that the second will be \"TGTCA\". Knowing one\n        of the two is enough.\n      </p>\n      <p>\n        Now we want to be able to compare two DNAs. For that we will try to\n        match ass many letter as possible between the two words. In the exemple\n        bellow, adding a space help us to align all the other letters.\n      </p>\n      <img src={alignement} />\n      <h2>Formalizing</h2>\n      <p>\n        We need to define what is a \"good way\" to align two DNAs. For that we\n        will define a<strong>score</strong> such that a <strong>good</strong>{\" \"}\n        alignment has a <strong>high</strong> score. Of course, a{\" \"}\n        <strong>bad</strong> alignment will have a <strong>low</strong> score.\n      </p>\n      <p>In an alignment we have 3 possibilities&nbsp;:</p>\n      <ul>\n        <li>\n          Letters <Match>match</Match> : That is what we want. So for each{\" \"}\n          <Match>match</Match> we give <Match>+1</Match>.{\" \"}\n        </li>\n        <li>\n          Letters <MissMatch>miss-match</MissMatch> : for exemple the A is\n          replaced by T in the other DNA. It's a{\" \"}\n          <MissMatch>substitution</MissMatch>, we want to avoid that so we will\n          give <MissMatch>-1</MissMatch> each time it appends.\n        </li>\n        <li>\n          Some time we prefer to use a <Deletion>space</Deletion>. In order to\n          improve alignement latter in the word we can prefer to use some\n          spaces. Those <Deletion>deletions</Deletion>, can append in DNAs but\n          they are more rare than <MissMatch>substitution</MissMatch>. So we\n          will give <Deletion>-2</Deletion> in order to say that we prefer{\" \"}\n          <MissMatch>substitution</MissMatch> to <Deletion>space</Deletion>.\n        </li>\n      </ul>\n      <p></p>\n      <p>\n        The score is just the sum of those values. Let see an exemple. If you\n        count the number of <Match>matches</Match>, of{\" \"}\n        <Deletion>deletions</Deletion> and <MissMatch>substitutions</MissMatch>{\" \"}\n        and you apply their respective <strong>score</strong> you get the\n        following result.\n        <br /> Score is : <Match>1</Match> + <MissMatch>(-1)</MissMatch> +{\" \"}\n        <Match>1</Match> + <Deletion>(-2)</Deletion> + <Match>1</Match> +{\" \"}\n        <MissMatch>(-1)</MissMatch> + <MissMatch>(-1)</MissMatch> +{\" \"}\n        <Match>1</Match> = -1\n      </p>\n      <img src={calcul_score} />\n      <p>\n        Of course you can choose other values. In biology there is some tables\n        in which they give the probabilities for a A to be replaced by a C, or\n        by a T or just to be deleted. The score will be more relevant with those\n        informations. But we don't care here.\n      </p>\n      <h2>Impossible to use naïve solution</h2>\n      <p>\n        Trying all the possibilities is just impossible. Let try to align 10\n        letters with 10 other ones. You can not modify letters order. All you\n        can do is add some spaces. But you have 20 possibilities to put one\n        space. If you want to consider solutions with 2 spaces you have 180\n        possibilities. For 3 spaces ? it's 1.140 possibilities It goes high\n        fast. Too fast to be tractable with real DNAs which are made of hundreds\n        and thousands of letters.\n      </p>\n      <p>\n        So we can not try all the alignments and look at the one with the lowest\n        score.\n      </p>\n      <h2>Recurrence relation are not enough</h2>\n      <p>\n        Trying every solution is not smart enough. So let's try{\" \"}\n        <strong>recurrence</strong>. We are trying to get the best alignment of\n        two DNAs. This alignment can finish with only 3 possibilities:\n      </p>\n      <ul>\n        <li>\n          We use the last letters of each DNA and they <Match>match</Match> or\n          they <MissMatch>substitution</MissMatch>\n        </li>\n        <li>\n          We choose to use a <Deletion>deletion</Deletion> for the first DNA\n        </li>\n        <li>\n          We choose to use a <Deletion>deletion</Deletion> for the second DNA\n        </li>\n      </ul>\n      <p></p>\n      <p>For those who prefer a scheme, There are the 3 solutions.</p>\n      <img src={trois_possibilites} />\n      <p>\n        For each of those possibilities, we have two smaller DNAs to align. So\n        we reuse the function on the remaining DNAs the compute there{\" \"}\n        <strong>best score</strong>. Like for tic-tac-toe, we{\" \"}\n        <strong>reduce the size of the problem</strong> at each time. So after\n        some time we will reach size 0 and get the solution.\n      </p>\n      <p>Mathematically, the formula is the following one&nbsp;:</p>\n      <img src={formule_rec_ADN} />\n      <p>\n        Do not panic if you don't understand it. Just read it slowly, it is the\n        translation of what we said before. If you want I plot its results later\n        in the article.\n      </p>\n      <p>\n        <strong>Problem</strong>&nbsp;: each time we use this equation, we get 3\n        smaller problems to solve. The we can say that we have an{\" \"}\n        <strong>exponential complexity</strong>. In fact this algorithm do what\n        we wanted to avoid. It try all the possibilities. But let se an exemple.\n      </p>\n      <h2>A feeling of \"déjà vue\"</h2>\n      <p>\n        Here is the <strong>tree of recurrence</strong> for a really simple\n        case, but an interesting one. We just want to aligne \"ACGT\" and \"AGT\".\n        but out tree has already 130 leafs. You don't need to read it completely\n        (you can click on it to get a full version) . You just need to notice\n        that each problem leads to 3 othe ones which are a bit smaller. Untill\n        we get a problem in which one of the DNA is empty so we can directly\n        comput its score.\n      </p>\n      <img src={arbre_min} onClick={handleClickOpen} />\n      <Dialog onClose={handleClose} open={openFullTree}>\n        <DialogTitle>Tree of possible alignments</DialogTitle>\n        <DialogContent>\n          <img src=\"\" alt=\"\" />\n        </DialogContent>\n      </Dialog>\n      <p>\n        You noticed a pattern? No? Of course, there are too many details. So I\n        cut i in three parts and use colors to represent problems. Each{\" \"}\n        <strong>problem</strong> is associated to a unique{\" \"}\n        <strong>color</strong>. So each time you see a box with the same color,\n        it means that they compute the same thing. Computing the same thing?\n        That's a bit stupid no?\n      </p>\n      <div className={classes.row}>\n        <div>\n          <img src={arbre_coupe1} />\n        </div>\n        <div>\n          <img src={arbre_coupe2} />\n        </div>\n        <div>\n          <img src={arbre_coupe3} />\n        </div>\n      </div>\n      <p>\n        Here some exemples. Each time you see a <strong>light green</strong>{\" \"}\n        box, it correspond to the alignment of <strong>A and A</strong>. The{\" \"}\n        <strong>light blue</strong> correspond to <strong>ACG and A</strong>.\n        The <strong>yellow</strong> are for <strong>ACG and AG</strong>, etc.\n        <br /> So on this tree we compute :\n      </p>\n      <ul>\n        <li>\n          <strong>25 times</strong> alignement between <strong>A</strong> and{\" \"}\n          <strong>A</strong>\n        </li>\n        <li>\n          <strong>5 times</strong> alignement between <strong>ACG</strong> and{\" \"}\n          <strong>A</strong>\n        </li>\n        <li>\n          <strong>3 times</strong> alignement between <strong>ACG</strong> and{\" \"}\n          <strong>AG</strong>\n        </li>\n      </ul>\n      <p>\n        It's clearly a waste of <strong>computing power</strong>\n        .&nbsp;To avoid this waste, we will need to store those results\n        somewhere. Thanks to this storage, we will reduce{\" \"}\n        <strong>time complexity</strong>, but it's not free since we neet to\n        increase\n        <strong>memory complexity</strong>. It seems obscure for you ? Don't\n        care, it will be okay after the next part.\n      </p>\n      <h2>The help of memoization</h2>\n      <p>\n        If you save in <strong>memory results of sub-problems</strong>, you will\n        not have to redo the computation. So the first time you see the problem\n        of aligning \"ACG\" with \"A\", you comput it and save the results. Each\n        time you will see it in the futur you can get directly the result from\n        memory. So in our tree each color box will appear only once.\n        <br />\n        You can see the result of this technic in the tree bellow. It's the same\n        except that I removed all the duplicated boxes. It's more efficient\n        don't you think?\n      </p>\n      <img src={arbre_elague} />\n      <p>\n        But how can we save all those results? We need something easy and fast\n        to save score of all our <strong>sub-problems</strong>. For that let's\n        start by counting how much sub-problem do we have.\n      </p>\n      <p>\n        A sub-problem is aligning two subsequence of our DNAs. For exemple\n        <strong>subsequences</strong> of \"ACGTCG\" are: \"ACGTCG\", \"ACGTC\",\n        \"ACGT\", \"ACG\", \"AC\", \"A\" and \"\".\n      </p>\n      <p>\n        So if our DNAs are made with n and m letters, there is (n+1){\" \"}\n        <strong>subsequences</strong> for the first DNA and (m+1){\" \"}\n        <strong>subsequences</strong> for the second DNA. By combining them we\n        get a total number of (n+1)(m+1) <strong>sub-problems</strong>. It will\n        be easy to store the in a table with (n+1) rows and (m+1) columns.\n      </p>\n      <p>\n        It's crazy&nbsp;! We started form a <strong>recurrence relation</strong>{\" \"}\n        which was time consuming, and we realize that it correspond to feeding a\n        table.\n      </p>\n      <p>\n        Here is an example of how this table work. It's easier to understand by\n        playing with it. Just move your mouse on boxes to know the corresponding\n        <strong>sub-problem</strong>.\n      </p>\n\n      <InteractiveGrid startWord1=\"ABCDEFGHIJ\" startWord2=\"DEFGH\" lang=\"en\" />\n\n      <h2>New version of the recurrence relation</h2>\n      <p>\n        We now have a table to feed. Now we will adapt the recurrence relation\n        to this table. For that we will just use an exemple. If I want to aligne\n        \"ACGTC\" and \"AGGA\" I still have tree possibilities for the end. Each of\n        those possibilities are represented by a colour.\n      </p>\n      <img src={recurrence_tableau} />\n      <p>\n        The two <Deletion>deletions</Deletion> will always be{\" \"}\n        <Deletion>deletions</Deletion>. But the third can be a{\" \"}\n        <Match>match</Match> or a <MissMatch>substitution</MissMatch>. We will\n        have a <Match>match</Match> if letters in the row and the column are the\n        same and a <MissMatch>substitution</MissMatch>\n        otherwise.\n      </p>\n\n      <p>\n        Move your mouse bellow to complet the table with our new recurrence\n        relation. If we have all the informations needed to fill the boxe the\n        relation will be applied. otherwise one of the missing sub problem will\n        be indicated.\n      </p>\n      <InteractiveRecurrence\n        startWord1=\"ATCGTCGA\"\n        startWord2=\"AGGTGCGTA\"\n        lang=\"en\"\n      />\n      <p>\n        You probably notices tat to fill a box you need three other ones . The{\" \"}\n        <strong>top</strong>, <strong>left</strong> and{\" \"}\n        <strong>top left</strong> boxes. So after filling the first line nd\n        first column, we can fill the table line by line, column by column or\n        with more creative paths.\n      </p>\n      <img src={parcourt_tableau} />\n\n      <p>\n        To conclude, we now have the best score of all the\n        <strong>sub-problems</strong>. Noticed that we inversed the order of\n        computation. Instead of starting by our problem and simplify it step by\n        step, we start by easies sub problems and add elements until we reach\n        our origina problem.\n      </p>\n      <p>\n        So the best score of our problem is the one in the box at the last\n        column and last line. The last box to be fill. We have the score but not\n        the alignment to get it. But we can get it easily for the table.\n      </p>\n      <p>\n        To get this <strong>best score</strong>we can come from to 3 sub\n        problems. Those in cases <strong>top</strong>, <strong>left</strong> and{\" \"}\n        <strong>top left</strong>. So let compute which of those sub-problems\n        allow to reach the best score. And we can repeat the operation until we\n        get arrive in the first line or the first column. Notice that this path\n        is not necessarily unique since there is not necessarily one optimal\n        alignement. This algorithm allow us to recover all of them.\n      </p>\n      <FullAlgo startWord1=\"ACGTCATC\" startWord2=\"ATGCGGC\" lang=\"en\" />\n    </Layout>\n  )\n}\nexport default Page\n"],"sourceRoot":""}