{"version":3,"sources":["webpack:///./src/components/DynamicProgram/atoms/RecurrenceSolutions/index.js","webpack:///./src/components/DynamicProgram/atoms/Links/index.js","webpack:///./src/components/DynamicProgram/explanations/FullAlgo/index.js","webpack:///./src/components/DynamicProgram/atoms/RecurrenceExplanation/index.js","webpack:///./src/components/DynamicProgram/atoms/Solutions/index.js","webpack:///./src/components/DynamicProgram/explanations/InteractiveRecurrence/index.js","webpack:///./src/components/DynamicProgram/atoms/RecurrenceRelation/index.js","webpack:///./src/components/DynamicProgram/constants.js","webpack:///./src/components/DynamicProgram/atoms/Grid/index.js","webpack:///./src/components/DynamicProgram/explanations/InteractiveGrid/index.js","webpack:///./src/pages/dynamic-programming/index.js"],"names":["RecurrenceSolutions","solutions","selectedSolution","setSelectedSolution","MAX_NUMBER_TO_DISPLAY","useState","startIndex","setStartIndex","slice","map","word1","word2","key","onEnter","isSelected","length","className","classes","buttonContainer","onClick","paths","includes","Links","links","showSolutions","Object","keys","reduce","accumulator","dx","dy","split","subWord1","subWord2","Dx","MEDIUM_CIRCLE_RADIUS","SQRT2","Dy","x1","COLUMN_SIZE","y1","x2","y2","link","transparent","matchLink","missmatchLink","emptyLink","FullAlgo","startWord1","startWord2","setWord1","setWord2","setSubWord1","setSubWord2","values","setValues","setLinks","showRecurrenceRelation","setShowRecurrenceRelation","setShowSolutions","setSolutions","useEffect","container","grid","inputContainer","onChange","event","target","value","toUpperCase","viewBox","style","width","maxHeight","Grid","RecurrenceRelation","subStep","explanation","RecurrenceExplanation","newValues","nextHorizontal","newSolutions","computeSolutions","state","sw1","sw2","char1","char2","newState","forEach","i","filter","e","join","used_dx","used_dy","fillLinksWithPaths","PRESENT","subSolutions","RECURRENCE_DATA","color","subSolution1","subSolution2","score","getCost","x","computationProblem","find","recurrenceShowBlock","solutionsContainer","alignLeft","leftBar","computationLine","hideLine","Words","wordsContainer","borderColor","Chars","charsContainer","match","mismatch","withEmpty","Score","Value","matchValue","mismatchValue","withEmptyValue","Solution","onMouseEnter","solutionContainer","_","index","InteractiveRecurrence","maxValue","isComputable","recurrentValues","sort","a","b","SAVE","saveLink","COMPUTE","goodLink","badLink","notComputableLink","cx","cy","r","circle","saveCircle","goodCircle","resultCircle","badCircle","notComputableCircle","stroke","LARGE_CIRCLE_RADIUS","Math","sqrt","char","tableLine","text-anchor","dominant-baseline","y","nomalWord","InteractiveCircle","accu","index1","index2","interactiveCircle","DisplayValues","v","undefined","InteractiveGrid","activeCircle","text","text1","text2","Page"],"mappings":"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","file":"component---src-pages-dynamic-programming-index-js-7c2ef9588b33a7474e8e.js","sourcesContent":["import React, { useState } from \"react\"\nimport { Solution } from \"src/components/DynamicProgram/atoms/Solutions\"\nimport classes from \"./styles.module.scss\"\n\nconst RecurrenceSolutions = ({\n  solutions,\n  selectedSolution,\n  setSelectedSolution,\n  MAX_NUMBER_TO_DISPLAY,\n}) => {\n  const [startIndex, setStartIndex] = useState(0)\n\n  return (\n    <div>\n      {solutions\n        .slice(\n          startIndex * MAX_NUMBER_TO_DISPLAY,\n          (startIndex + 1) * MAX_NUMBER_TO_DISPLAY\n        )\n        .map(({ word1, word2 }) => (\n          <Solution\n            key={`${word1}-${word2}`}\n            word1={word1}\n            word2={word2}\n            onEnter={() => setSelectedSolution(`${word1}-${word2}`)}\n            isSelected={`${word1}-${word2}` === selectedSolution}\n          />\n        ))}\n      {solutions.length > MAX_NUMBER_TO_DISPLAY && (\n        <div className={classes.buttonContainer}>\n          {startIndex > 0 ? (\n            <button\n              onClick={() => {\n                setStartIndex(startIndex => startIndex - 1)\n              }}\n            >\n              Prev\n            </button>\n          ) : (\n            <div />\n          )}\n          <p>\n            {startIndex * MAX_NUMBER_TO_DISPLAY + 1}-\n            {(startIndex + 1) * MAX_NUMBER_TO_DISPLAY} / {solutions.length}\n          </p>\n          {solutions.length > (startIndex + 1) * MAX_NUMBER_TO_DISPLAY && (\n            <button\n              onClick={() => {\n                setStartIndex(startIndex => startIndex + 1)\n              }}\n            >\n              Next\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\nexport default RecurrenceSolutions\n","import React from \"react\"\nimport { COLUMN_SIZE, MEDIUM_CIRCLE_RADIUS, SQRT2 } from \"../../constants.js\"\nimport classes from \"./styles.module.scss\"\n\nexport const computeSolutions = (links, state, solutions) => {\n  if (!links[state]) return solutions\n\n  const [subWord1, subWord2] = state.split(\"-\")\n  return links[state].reduce((accumulator, { dx, dy }) => {\n    const sw1 = subWord1.slice(0, subWord1.length + dx)\n    const sw2 = subWord2.slice(0, subWord2.length + dy)\n    const char1 = subWord1.slice(subWord1.length + dx, subWord1.length)\n    const char2 = subWord2.slice(subWord2.length + dy, subWord2.length)\n\n    const newState = `${sw1}-${sw2}`\n    const newSolutions = solutions.map(({ word1, word2 }) => ({\n      word1: `${char1 || \"_\"}${word1}`,\n      word2: `${char2 || \"_\"}${word2}`,\n    }))\n\n    return [...accumulator, ...computeSolutions(links, newState, newSolutions)]\n  }, [])\n}\n\nexport const fillLinksWithPaths = (links, solutions) => {\n  solutions.forEach(({ word1, word2 }) => {\n    for (let i = 1; i <= word1.length; i++) {\n      const subWord1 = word1\n        .slice(0, i)\n        .split(\"\")\n        .filter(e => e !== \"_\")\n        .join(\"\")\n      const subWord2 = word2\n        .slice(0, i)\n        .split(\"\")\n        .filter(e => e !== \"_\")\n        .join(\"\")\n\n      const char1 = word1.slice(i - 1, i)\n      const char2 = word2.slice(i - 1, i)\n\n      const used_dx = char1 === \"_\" ? 0 : -1\n      const used_dy = char2 === \"_\" ? 0 : -1\n      const key = `_${subWord1}-_${subWord2}`\n      links[key] = links[key].map(({ dx, dy, paths }) =>\n        dx === used_dx && dy === used_dy\n          ? { dx, dy, paths: [...paths, `${word1}-${word2}`] }\n          : { dx, dy, paths }\n      )\n    }\n  })\n  return links\n}\n\nconst isSelected = (selectedSolution, paths) => paths.includes(selectedSolution)\n\nconst Links = ({ links, showSolutions, selectedSolution }) => {\n  return (\n    <>\n      {Object.keys(links).reduce((accumulator, key) => {\n        return [\n          ...accumulator,\n          ...links[key].map(({ dx, dy, paths }) => {\n            const [subWord1, subWord2] = key.split(\"-\")\n            const Dx =\n              dx === 0\n                ? 0\n                : dy === 0\n                ? MEDIUM_CIRCLE_RADIUS\n                : MEDIUM_CIRCLE_RADIUS / SQRT2\n\n            const Dy =\n              dy === 0\n                ? 0\n                : dx === 0\n                ? MEDIUM_CIRCLE_RADIUS\n                : MEDIUM_CIRCLE_RADIUS / SQRT2\n\n            return subWord1.length + dx > 0 && subWord2.length + dy > 0 ? (\n              <line\n                x1={COLUMN_SIZE * (subWord1.length + dx + 0.5) + Dx}\n                y1={COLUMN_SIZE * (subWord2.length + dy + 0.5) + Dy}\n                x2={COLUMN_SIZE * (subWord1.length + 0.5) - Dx}\n                y2={COLUMN_SIZE * (subWord2.length + 0.5) - Dy}\n                className={`${classes.link} ${\n                  showSolutions && paths.length === 0 ? classes.transparent : \"\"\n                } ${\n                  showSolutions && isSelected(selectedSolution, paths)\n                    ? dx === dy\n                      ? subWord1[subWord1.length - 1] ===\n                        subWord2[subWord2.length - 1]\n                        ? classes.matchLink\n                        : classes.missmatchLink\n                      : classes.emptyLink\n                    : \"\"\n                }`}\n              />\n            ) : null\n          }),\n        ]\n      }, [])}\n    </>\n  )\n}\nexport default Links\n","import React, { useState, useEffect } from \"react\"\nimport {\n  Grid,\n  InteractiveCircle,\n  DisplayValues,\n} from \"src/components/DynamicProgram/atoms/Grid\"\nimport { COLUMN_SIZE } from \"src/components/DynamicProgram/constants.js\"\n\nimport classes from \"./styles.module.scss\"\n\nimport RecurrenceRelation from \"src/components/DynamicProgram/atoms/RecurrenceRelation\"\nimport RecurrenceExplanation from \"src/components/DynamicProgram/atoms/RecurrenceExplanation\"\nimport RecurrenceSolutions from \"src/components/DynamicProgram/atoms/RecurrenceSolutions\"\nimport Links, {\n  computeSolutions,\n  fillLinksWithPaths,\n} from \"src/components/DynamicProgram/atoms/Links\"\n\nconst MAX_NUMBER_OF_SOLUTION_TO_DISPLAY = 10\n\nconst nextHorizontal = (subWord1, subWord2, word1, word2) => {\n  if (subWord1.length < word1.length + 1)\n    return { subWord1: `_${word1.slice(0, subWord1.length)}`, subWord2 }\n  if (subWord2.length < word2.length + 1)\n    return { subWord1: \"_\", subWord2: `_${word2.slice(0, subWord2.length)}` }\n  return null\n}\nconst nextVertical = (subWord1, subWord2, word1, word2) => {\n  if (subWord2.length < word2.length + 1)\n    return { subWord2: `_${word2.slice(0, subWord2.length)}`, subWord1 }\n  if (subWord1.length < word1.length + 1)\n    return { subWord2: \"_\", subWord1: `_${word1.slice(0, subWord1.length)}` }\n  return null\n}\n\nconst FullAlgo = ({ startWord1, startWord2 }) => {\n  const [word1, setWord1] = useState(startWord1)\n  const [word2, setWord2] = useState(startWord2)\n  const [subWord1, setSubWord1] = useState(`_`)\n  const [subWord2, setSubWord2] = useState(`_`)\n  const [values, setValues] = useState({ \"_-_\": 0 })\n  const [links, setLinks] = useState({})\n  const [showRecurrenceRelation, setShowRecurrenceRelation] = useState(true)\n  const [showSolutions, setShowSolutions] = useState(false)\n  const [solutions, setSolutions] = useState([])\n  const [selectedSolution, setSelectedSolution] = useState(\"\")\n\n  useEffect(() => {\n    setValues({ \"_-_\": 0 })\n    setLinks({})\n    setShowRecurrenceRelation(true)\n    setSubWord1(`_`)\n    setSubWord2(`_`)\n    setShowSolutions(false)\n    setSolutions([])\n  }, [word1, word2])\n\n  const next = () => {\n    const newValues = nextHorizontal(subWord1, subWord2, word1, word2)\n    if (!newValues && !showSolutions) {\n      const newSolutions = computeSolutions(links, `_${word1}-_${word2}`, [\n        { word1: \"\", word2: \"\" },\n      ])\n      setSolutions(newSolutions)\n      setLinks(fillLinksWithPaths(links, newSolutions))\n      setShowRecurrenceRelation(false)\n      setShowSolutions(true)\n    } else if (!showSolutions) {\n      const { subWord1, subWord2 } = newValues\n      setSubWord1(subWord1)\n      setSubWord2(subWord2)\n    }\n  }\n\n  return (\n    <>\n      <div className={classes.container}>\n        <div className={classes.grid}>\n          <div className={classes.inputContainer}>\n            <input\n              onChange={event => setWord1(event.target.value.toUpperCase())}\n              value={word1}\n            />\n            <input\n              onChange={event => setWord2(event.target.value.toUpperCase())}\n              value={word2}\n            />\n          </div>\n          <svg\n            viewBox={`0 0 ${COLUMN_SIZE * (word1.length + 2)} ${COLUMN_SIZE *\n              (word2.length + 2)}`}\n            style={{ width: \"100%\", maxHeight: \"20cm\" }}\n          >\n            <Grid word1={word1} word2={word2} />\n            <DisplayValues word1={word1} word2={word2} values={values} />\n\n            {showRecurrenceRelation && (\n              <RecurrenceRelation\n                subWord1={subWord1}\n                subWord2={subWord2}\n                values={values}\n                setValues={setValues}\n                links={links}\n                setLinks={setLinks}\n                subStep=\"COMPUTE\"\n              />\n            )}\n            <Links\n              links={links}\n              showSolutions={showSolutions}\n              selectedSolution={selectedSolution}\n            />\n          </svg>\n        </div>\n        <div className={classes.explanation}>\n          {showSolutions ? (\n            <RecurrenceSolutions\n              solutions={solutions}\n              selectedSolution={selectedSolution}\n              setSelectedSolution={setSelectedSolution}\n              MAX_NUMBER_TO_DISPLAY={MAX_NUMBER_OF_SOLUTION_TO_DISPLAY}\n            />\n          ) : (\n            <RecurrenceExplanation\n              subWord1={subWord1}\n              subWord2={subWord2}\n              values={values}\n            />\n          )}\n        </div>\n      </div>\n      <button onClick={next}>Next</button>\n    </>\n  )\n}\n\nexport default FullAlgo\n","import React from \"react\"\nimport { PRESENT, COMPUTE, SAVE, RECURRENCE_DATA } from \"../../constants.js\"\nimport classes from \"./styles.module.scss\"\nimport {\n  Words,\n  Chars,\n  Score,\n  Value,\n} from \"src/components/DynamicProgram/atoms/Solutions\"\nimport { getCost } from \"../RecurrenceRelation\"\n\nconst RecurrenceExplanation = ({ subWord1, subWord2, values, subStep }) => {\n  subStep = subStep || PRESENT\n\n  const key = `${subWord1}-${subWord2}`\n\n  const subSolutions = RECURRENCE_DATA.slice(0, RECURRENCE_DATA.length - 1)\n    .map(({ dx, dy, color }) => {\n      if (subWord1.length + dx > 0 && subWord2.length + dy > 0) {\n        const subSolution1 = subWord1.slice(0, subWord1.length + dx)\n        const subSolution2 = subWord2.slice(0, subWord2.length + dy)\n        const char1 = subWord1.slice(subWord1.length + dx, subWord1.length)\n        const char2 = subWord2.slice(subWord2.length + dy, subWord2.length)\n\n        const value = values[`${subSolution1}-${subSolution2}`]\n        const score =\n          typeof value === \"number\" ? value + getCost(char1, char2) : \"?\"\n        return { subSolution1, subSolution2, char1, char2, value, score, color }\n      }\n    })\n    .filter(x => !!x)\n\n  const computationProblem = subSolutions.find(\n    //return the first element with missing value for recurrence computation\n    ({ score }) => score === \"?\"\n  )\n\n  return (\n    <div className={classes.container}>\n      {/* SHOW */}\n      <div className={classes.recurrenceShowBlock}>\n        <Words word1={subWord1} word2={subWord2} /> =\n        <div className={classes.solutionsContainer}>\n          {subSolutions.map(\n            ({ subSolution2, subSolution1, char2, char1, color }) => (\n              <div className={classes.alignLeft}>\n                <Words\n                  word1={subSolution1}\n                  word2={subSolution2}\n                  color={color}\n                />\n                <Chars char1={char1} char2={char2} />\n              </div>\n            )\n          )}\n        </div>\n      </div>\n      {/* compute */}\n      {computationProblem ? (\n        <>\n          <p>\n            We don't know the minimal cost of{\" \"}\n            <Words\n              word1={computationProblem.subSolution1}\n              word2={computationProblem.subSolution2}\n            />\n          </p>\n          <p>\n            You need it to compute the minimal cost of{\" \"}\n            <Words word1={subWord1} word2={subWord2} />\n          </p>\n        </>\n      ) : (\n        <div className={classes.recurrenceShowBlock}>\n          <Score value={values[`${subWord1}-${subWord2}`]} />=\n          {subSolutions.length > 1 ? \" max \" : \"\"}\n          <div\n            className={`${classes.solutionsContainer}\n              ${subSolutions.length > 1 ? classes.leftBar : \"\"}`}\n          >\n            {subSolutions.map(\n              ({ subSolution2, subSolution1, char2, char1, color, score }) => (\n                <div\n                  className={`${classes.alignLeft} ${classes.computationLine} ${\n                    score !== values[key] ? classes.hideLine : \"\"\n                  }`}\n                >\n                  <Score\n                    value={values[`${subSolution1}-${subSolution2}`]}\n                    color={color}\n                  />\n                  {\" + \"}\n                  <Value char1={char1} char2={char2} />\n                  {` = ${score}`}\n                </div>\n              )\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\nexport default RecurrenceExplanation\n","import React from \"react\"\nimport classes from \"./styles.module.scss\"\nimport { getCost } from \"../RecurrenceRelation\"\n\nexport const Words = ({ word1, word2, color }) => (\n  <div\n    className={classes.wordsContainer}\n    style={color ? { borderColor: color } : {}}\n  >\n    <p className={classes.word1}>{word1 || \"_\"}</p>\n    <p className={classes.word2}>{word2 || \"_\"}</p>\n  </div>\n)\n\nexport const Chars = ({ char1, char2 }) => (\n  <div\n    className={`${classes.charsContainer} ${\n      char1 === char2\n        ? classes.match\n        : !char1 || !char2 || char1 === \"_\" || char2 === \"_\"\n        ? classes.withEmpty\n        : classes.mismatch\n    }`}\n  >\n    <p className={classes.char1}>{char1 || \"_\"}</p>\n    <p className={classes.char2}>{char2 || \"_\"}</p>\n  </div>\n)\n\nexport const Score = ({ value, color }) => (\n  <span className={classes.score} style={color ? { borderColor: color } : {}}>\n    {typeof value === \"number\" ? value : \"?\"}\n  </span>\n)\n\nexport const Value = ({ char1, char2 }) => (\n  <span\n    className={`${\n      char1 === char2\n        ? classes.matchValue\n        : !char1 || !char2 || char1 === \"_\" || char2 === \"_\"\n        ? classes.withEmptyValue\n        : classes.mismatchValue\n    }`}\n  >\n    {getCost(char1, char2)}\n  </span>\n)\n\nexport const Solution = ({ word1, word2, onEnter, isSelected }) => (\n  <div\n    onMouseEnter={onEnter}\n    className={`${classes.solutionContainer} ${\n      isSelected ? classes.isSelected : \"\"\n    }`}\n  >\n    {word1.split(\"\").map((_, index) => (\n      <Chars char1={word1[index]} char2={word2[index]} />\n    ))}\n  </div>\n)\n","import React, { useState } from \"react\"\nimport {\n  Grid,\n  InteractiveCircle,\n  DisplayValues,\n} from \"src/components/DynamicProgram/atoms/Grid\"\nimport { COLUMN_SIZE } from \"src/components/DynamicProgram/constants.js\"\n\nimport classes from \"./styles.module.scss\"\n\nimport RecurrenceRelation from \"src/components/DynamicProgram/atoms/RecurrenceRelation\"\nimport RecurrenceExplanation from \"src/components/DynamicProgram/atoms/RecurrenceExplanation\"\n\nconst InteractiveRecurrence = ({ startWord1, startWord2 }) => {\n  const [word1, setWord1] = useState(startWord1)\n  const [word2, setWord2] = useState(startWord2)\n  const [subWord1, setSubWord1] = useState(`_${startWord1}`)\n  const [subWord2, setSubWord2] = useState(`_${startWord2}`)\n  const [values, setValues] = useState({ \"_-_\": 0 })\n\n  return (\n    <div className={classes.container}>\n      <div className={classes.grid}>\n        <div className={classes.inputContainer}>\n          <input\n            onChange={event => setWord1(event.target.value.toUpperCase())}\n            value={word1}\n          />\n          <input\n            onChange={event => setWord2(event.target.value.toUpperCase())}\n            value={word2}\n          />\n        </div>\n        <svg\n          viewBox={`0 0 ${COLUMN_SIZE * (word1.length + 2)} ${COLUMN_SIZE *\n            (word2.length + 2)}`}\n          style={{ width: \"100%\", maxHeight: \"20cm\" }}\n        >\n          <Grid word1={word1} word2={word2} />\n          <DisplayValues word1={word1} word2={word2} values={values} />\n\n          <RecurrenceRelation\n            subWord1={subWord1}\n            subWord2={subWord2}\n            values={values}\n            setValues={setValues}\n            subStep=\"COMPUTE\"\n          />\n          <InteractiveCircle\n            word1={word1}\n            word2={word2}\n            onEnter={(sw1, sw2) => () => {\n              setSubWord1(sw1)\n              setSubWord2(sw2)\n            }}\n          />\n        </svg>\n      </div>\n      <div className={classes.explanation}>\n        <RecurrenceExplanation\n          subWord1={subWord1}\n          subWord2={subWord2}\n          values={values}\n        />\n      </div>\n    </div>\n  )\n}\n\nexport default InteractiveRecurrence\n","import React from \"react\"\nimport {\n  COLUMN_SIZE,\n  RECURRENCE_DATA,\n  MEDIUM_CIRCLE_RADIUS,\n  SQRT2,\n  PRESENT,\n  COMPUTE,\n  SAVE,\n} from \"../../constants.js\"\nimport classes from \"./styles.module.scss\"\n\nexport const getCost = (char1, char2) => {\n  if (char1 === char2) return 1\n  if (char1 === \"_\" || char2 === \"_\") return -2\n  if (char1 === \"\" || char2 === \"\") return -2\n  return -1\n}\n\nconst RecurrenceRelation = ({\n  subWord1,\n  subWord2,\n  values,\n  setValues,\n  links,\n  setLinks,\n  subStep,\n}) => {\n  subStep = subStep || PRESENT\n  const key = `${subWord1}-${subWord2}`\n  let isComputable = false\n  let maxValue\n  const recurrentValues = {}\n\n  isComputable = true\n  RECURRENCE_DATA.slice(0, RECURRENCE_DATA.length - 1).forEach(\n    ({ dx, dy }, index) => {\n      if (subWord1.length + dx > 0 && subWord2.length + dy > 0) {\n        const sw1 = subWord1.slice(0, subWord1.length + dx)\n        const sw2 = subWord2.slice(0, subWord2.length + dy)\n        const char1 = subWord1.slice(subWord1.length + dx, subWord1.length)\n        const char2 = subWord2.slice(subWord2.length + dy, subWord2.length)\n        if (typeof values[`${sw1}-${sw2}`] === \"number\") {\n          recurrentValues[index] = {\n            value: values[`${sw1}-${sw2}`] + getCost(char1, char2),\n            dx,\n            dy,\n          }\n        } else {\n          isComputable = false\n        }\n      }\n    }\n  )\n  if (isComputable) {\n    maxValue = Object.keys(recurrentValues)\n      .map(key => recurrentValues[key].value)\n      .sort((a, b) => b - a)[0]\n    if (typeof values[key] !== \"number\") {\n      setValues({ ...values, [key]: maxValue })\n      if (links && setLinks) {\n        setLinks({\n          ...links,\n          [key]: Object.keys(recurrentValues)\n            .filter(key => recurrentValues[key].value === maxValue)\n            .map(key => ({\n              dx: recurrentValues[key].dx,\n              dy: recurrentValues[key].dy,\n              paths: [],\n            })),\n        })\n      }\n    }\n  }\n\n  return (\n    <>\n      {RECURRENCE_DATA.slice(0, RECURRENCE_DATA.length - 1).map(\n        ({ dx, dy }, index) => {\n          const Dx =\n            dx === 0\n              ? 0\n              : dy === 0\n              ? MEDIUM_CIRCLE_RADIUS\n              : MEDIUM_CIRCLE_RADIUS / SQRT2\n          const Dy =\n            dy === 0\n              ? 0\n              : dx === 0\n              ? MEDIUM_CIRCLE_RADIUS\n              : MEDIUM_CIRCLE_RADIUS / SQRT2\n          return subWord1.length + dx > 0 && subWord2.length + dy > 0 ? (\n            <line\n              x1={COLUMN_SIZE * (subWord1.length + dx + 0.5) + Dx}\n              y1={COLUMN_SIZE * (subWord2.length + dy + 0.5) + Dy}\n              x2={COLUMN_SIZE * (subWord1.length + 0.5) - Dx}\n              y2={COLUMN_SIZE * (subWord2.length + 0.5) - Dy}\n              className={`${classes.link} ${\n                subStep === SAVE\n                  ? classes.saveLink\n                  : subStep === COMPUTE &&\n                    isComputable &&\n                    recurrentValues[index] &&\n                    recurrentValues[index].value === maxValue\n                  ? classes.goodLink\n                  : subStep === COMPUTE && isComputable\n                  ? classes.badLink\n                  : classes.notComputableLink\n              }`}\n            />\n          ) : null\n        }\n      )}\n      {RECURRENCE_DATA.map(({ dx, dy, color }, index) =>\n        subWord1.length + dx > 0 && subWord2.length + dy > 0 ? (\n          <circle\n            cx={COLUMN_SIZE * (subWord1.length + dx + 0.5)}\n            cy={COLUMN_SIZE * (subWord2.length + dy + 0.5)}\n            r={MEDIUM_CIRCLE_RADIUS}\n            className={`${classes.circle}  ${\n              subStep === SAVE\n                ? classes.saveCircle\n                : subStep === COMPUTE &&\n                  isComputable &&\n                  recurrentValues[index] &&\n                  recurrentValues[index].value === maxValue\n                ? classes.goodCircle\n                : RECURRENCE_DATA.length === index + 1\n                ? classes.resultCircle\n                : subStep === COMPUTE && isComputable\n                ? classes.badCircle\n                : classes.notComputableCircle\n            }`}\n            style={subStep === PRESENT ? { stroke: color } : {}}\n          />\n        ) : null\n      )}\n    </>\n  )\n}\nexport default RecurrenceRelation\n","export const COLUMN_SIZE = 40\nexport const LARGE_CIRCLE_RADIUS = COLUMN_SIZE / 2 - 1\nexport const MEDIUM_CIRCLE_RADIUS = COLUMN_SIZE / 3\nexport const SMALL_CIRCLE_RADIUS = COLUMN_SIZE / 4\nexport const SQRT2 = Math.sqrt(2)\n\nexport const RECURRENCE_DATA = [\n  //all the circles are linked to the ast one\n  { dx: -1, dy: -1, color: \"red\" },\n  { dx: 0, dy: -1, color: \"blue\" },\n  { dx: -1, dy: 0, color: \"green\" },\n  { dx: 0, dy: 0, color: \"orange\" },\n]\n\nexport const PRESENT = \"PRESENT\"\nexport const COMPUTE = \"COMPUTE\"\nexport const SAVE = \"SAVE\"\n","import React from \"react\"\nimport classes from \"./styles.module.scss\"\nimport {\n  COLUMN_SIZE,\n  LARGE_CIRCLE_RADIUS,\n  MEDIUM_CIRCLE_RADIUS,\n} from \"src/components/DynamicProgram/constants.js\"\n\nexport const Grid = ({ word1, word2, subWord1, subWord2 }) => (\n  <>\n    {`_${word1}`.split(\"\").map((char, index) => (\n      <>\n        <line\n          x1={COLUMN_SIZE * (index + 1)}\n          y1={0}\n          x2={COLUMN_SIZE * (index + 1)}\n          y2={COLUMN_SIZE * (word2.length + 2)}\n          className={classes.tableLine}\n        />\n        <text\n          text-anchor=\"middle\"\n          dominant-baseline=\"middle\"\n          x={COLUMN_SIZE * (index + 1.5)}\n          y={COLUMN_SIZE * 0.5}\n          className={\n            subWord1 && index < subWord1.length\n              ? classes.subWord1\n              : classes.nomalWord\n          }\n        >\n          {char}\n        </text>\n      </>\n    ))}\n    {`_${word2}`.split(\"\").map((char, index) => (\n      <>\n        <line\n          x1={0}\n          y1={COLUMN_SIZE * (index + 1)}\n          x2={COLUMN_SIZE * (word1.length + 2)}\n          y2={COLUMN_SIZE * (index + 1)}\n          className={classes.tableLine}\n        />\n        <text\n          text-anchor=\"middle\"\n          dominant-baseline=\"middle\"\n          y={COLUMN_SIZE * (index + 1.5)}\n          x={COLUMN_SIZE * 0.5}\n          className={\n            subWord2 && index < subWord2.length\n              ? classes.subWord2\n              : classes.nomalWord\n          }\n        >\n          {char}\n        </text>\n      </>\n    ))}\n  </>\n)\n\nexport const InteractiveCircle = ({ word1, word2, onEnter }) => (\n  <>\n    {`_${word1}`.split(\"\").reduce(\n      (accu, _, index1) => [\n        ...accu,\n        ...`_${word2}`\n          .split(\"\")\n          .map((_, index2) => (\n            <circle\n              className={classes.interactiveCircle}\n              cx={COLUMN_SIZE * (index1 + 1.5)}\n              cy={COLUMN_SIZE * (index2 + 1.5)}\n              r={LARGE_CIRCLE_RADIUS}\n              onMouseEnter={onEnter(\n                `_${word1}`.slice(0, index1 + 1),\n                `_${word2}`.slice(0, index2 + 1)\n              )}\n            />\n          )),\n      ],\n      `_${word2}`\n        .split(\"\")\n        .map((_, index2) => (\n          <circle\n            className={classes.interactiveCircle}\n            cx={COLUMN_SIZE * (0 + 1.5)}\n            cy={COLUMN_SIZE * (index2 + 1.5)}\n            r={LARGE_CIRCLE_RADIUS}\n            onMouseEnter={onEnter(\n              `_${word1}`.slice(0, 0 + 1),\n              `_${word2}`.slice(0, index2 + 1)\n            )}\n          />\n        ))\n    )}\n  </>\n)\n\nexport const DisplayValues = ({ word1, word2, values }) => {\n  return (\n    <>\n      {`_${word1}`.split(\"\").reduce(\n        (accu, _, index1) => [\n          ...accu,\n          ...`_${word2}`.split(\"\").map((_, index2) => {\n            const key =\n              `_${word1}`.slice(0, index1 + 1) +\n              \"-\" +\n              `_${word2}`.slice(0, index2 + 1)\n            const v = values[key]\n            return v !== undefined ? (\n              <>\n                <circle\n                  className={classes.interactiveCircle}\n                  cx={COLUMN_SIZE * (index1 + 1.5)}\n                  cy={COLUMN_SIZE * (index2 + 1.5)}\n                  r={MEDIUM_CIRCLE_RADIUS}\n                />\n                <text\n                  text-anchor=\"middle\"\n                  dominant-baseline=\"middle\"\n                  x={COLUMN_SIZE * (index1 + 1.5)}\n                  y={COLUMN_SIZE * (index2 + 1.5)}\n                >\n                  {v}\n                </text>\n              </>\n            ) : null\n          }),\n        ],\n        `_${word2}`.split(\"\").map((_, index2) => {\n          const key = \"_-\" + `_${word2}`.slice(0, index2 + 1)\n          const v = values[key]\n          return v ? (\n            <>\n              <circle\n                className={classes.interactiveCircle}\n                cx={COLUMN_SIZE * 1.5}\n                cy={COLUMN_SIZE * (index2 + 1.5)}\n                r={MEDIUM_CIRCLE_RADIUS}\n              />\n              <text\n                text-anchor=\"middle\"\n                dominant-baseline=\"middle\"\n                x={COLUMN_SIZE * 1.5}\n                y={COLUMN_SIZE * (index2 + 1.5)}\n              >\n                {v}\n              </text>\n            </>\n          ) : null\n        })\n      )}\n    </>\n  )\n}\n","import React, { useState } from \"react\"\nimport {\n  Grid,\n  InteractiveCircle,\n} from \"src/components/DynamicProgram/atoms/Grid\"\nimport { COLUMN_SIZE } from \"src/components/DynamicProgram/constants.js\"\nimport classes from \"./styles.module.scss\"\n\nconst InteractiveGrid = ({ startWord1, startWord2 }) => {\n  const [word1, setWord1] = useState(startWord1)\n  const [word2, setWord2] = useState(startWord2)\n  const [subWord1, setSubWord1] = useState(`_${startWord1}`)\n  const [subWord2, setSubWord2] = useState(`_${startWord2}`)\n\n  return (\n    <div className={classes.container}>\n      <div className={classes.inputContainer}>\n        <input\n          onChange={event => setWord1(event.target.value.toUpperCase())}\n          value={word1}\n        />\n        <input\n          onChange={event => setWord2(event.target.value.toUpperCase())}\n          value={word2}\n        />\n      </div>\n      <svg\n        viewBox={`0 0 ${COLUMN_SIZE * (word1.length + 2)} ${COLUMN_SIZE *\n          (word2.length + 2)}`}\n        style={{ width: \"100%\", maxHeight: \"20cm\" }}\n      >\n        <Grid\n          word1={word1}\n          word2={word2}\n          subWord1={subWord1}\n          subWord2={subWord2}\n        />\n        <InteractiveCircle\n          word1={word1}\n          word2={word2}\n          onEnter={(sw1, sw2) => () => {\n            setSubWord1(sw1)\n            setSubWord2(sw2)\n          }}\n        />\n        <circle\n          className={classes.activeCircle}\n          cx={COLUMN_SIZE * (subWord1.length + 0.5)}\n          cy={COLUMN_SIZE * (subWord2.length + 0.5)}\n          r={COLUMN_SIZE / 4}\n        ></circle>\n      </svg>\n      <p className={`${classes.text} ${classes.text1}`}>\n        {subWord1.slice(1) || \"_\"}\n      </p>\n      <p className={`${classes.text} ${classes.text2}`}>\n        {subWord2.slice(1) || \"_\"}\n      </p>\n    </div>\n  )\n}\n\nexport default InteractiveGrid\n","import React from \"react\"\nimport InteractiveGrid from \"src/components/DynamicProgram/explanations/InteractiveGrid\"\nimport InteractiveRecurrence from \"src/components/DynamicProgram/explanations/InteractiveRecurrence\"\nimport FullAlgo from \"src/components/DynamicProgram/explanations/FullAlgo\"\nconst Page = () => (\n  <>\n    <FullAlgo startWord1=\"ABCD\" startWord2=\"ABD\" />\n    <InteractiveGrid startWord1=\"ABBABABBBAA\" startWord2=\"ABBABABABBAB\" />\n    <InteractiveRecurrence startWord1=\"ABBABABBBAA\" startWord2=\"ABBABABABBAB\" />\n  </>\n)\n\nexport default Page\n"],"sourceRoot":""}